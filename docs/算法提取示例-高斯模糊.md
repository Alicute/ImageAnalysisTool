# 算法提取示例：从D.cs提取高斯模糊算法

## 概述

本文档展示如何从D.cs文件中提取高斯模糊算法，并将其重构为现代化的C#实现。

## D.cs中的高斯模糊实现分析

### 1. 外部DLL调用
D.cs中的高斯模糊功能通过调用外部DLL实现：

```csharp
// 来自D.cs的原始代码
[DllImport("ImageMaster.dll", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Unicode, ExactSpelling = true)]
private unsafe static extern int IM_GaussBlur_PureC(byte* Src, byte* Dest, int Width, int Height, int Stride, float Radius);

[DllImport("ImageMaster.dll", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Unicode, ExactSpelling = true)]
private unsafe static extern int IM_GaussBlur_SSE(byte* Src, byte* Dest, int Width, int Height, int Stride, float Radius);

[DllImport("ImageMaster.dll", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Unicode, ExactSpelling = true)]
private unsafe static extern int IM_GaussBlur_AVX(byte* Src, byte* Dest, int Width, int Height, int Stride, float Radius);
```

### 2. 调用方式
```csharp
// 在BlurBasedDialog中的使用
if (Text.Equals("高斯模糊"))
{
    if (!ChkImproved.Checked)
    {
        if (CmbDirection.SelectedIndex == 0)
        {
            IM_GaussBlur_SSE(Clone, canvas.ImageData, canvas.Image.Width, canvas.Image.Height, canvas.Stride, Radius.Value);
        }
        // ... 其他实现选择
    }
}
```

### 3. 参数说明
- `Src`: 源图像数据指针
- `Dest`: 目标图像数据指针  
- `Width`: 图像宽度
- `Height`: 图像高度
- `Stride`: 图像行字节数
- `Radius`: 高斯模糊半径

## 重构为现代C#实现

### 1. 接口定义
```csharp
using System.Threading.Tasks;

namespace ImageProcessingTool.Core.Interfaces
{
    public interface IImageFilter
    {
        string Name { get; }
        string Description { get; }
        Task<ImageData> ApplyAsync(ImageData input, object parameters = null);
    }
}

namespace ImageProcessingTool.Core.Models
{
    public class GaussianBlurParameters
    {
        public float Radius { get; set; } = 1.0f;
        public bool SeparableFilter { get; set; } = true;
        public int KernelSize { get; set; } = 0; // 0表示自动计算
    }
}
```

### 2. 高斯模糊滤波器实现
```csharp
using System;
using System.Threading.Tasks;
using ImageProcessingTool.Core.Interfaces;
using ImageProcessingTool.Core.Models;

namespace ImageProcessingTool.Core.Algorithms.Filters
{
    public class GaussianBlurFilter : IImageFilter
    {
        public string Name => "高斯模糊";
        public string Description => "使用高斯核进行图像模糊处理，支持可分离滤波器优化";

        public async Task<ImageData> ApplyAsync(ImageData input, object parameters = null)
        {
            var param = parameters as GaussianBlurParameters ?? new GaussianBlurParameters();
            
            return await Task.Run(() =>
            {
                if (param.SeparableFilter)
                {
                    return ApplySeparableGaussianBlur(input, param.Radius);
                }
                else
                {
                    return Apply2DGaussianBlur(input, param.Radius, param.KernelSize);
                }
            });
        }

        /// <summary>
        /// 可分离高斯滤波器实现（性能更好）
        /// </summary>
        private ImageData ApplySeparableGaussianBlur(ImageData input, float radius)
        {
            // 第一步：水平方向滤波
            var horizontal = ApplyHorizontalGaussian(input, radius);
            
            // 第二步：垂直方向滤波
            var result = ApplyVerticalGaussian(horizontal, radius);
            
            return result;
        }

        /// <summary>
        /// 水平方向高斯滤波
        /// </summary>
        private ImageData ApplyHorizontalGaussian(ImageData input, float radius)
        {
            var kernel = GenerateGaussianKernel1D(radius);
            var result = input.Clone();
            int kernelSize = kernel.Length;
            int offset = kernelSize / 2;

            var srcSpan = input.PixelData.AsSpan();
            var dstSpan = result.PixelData.AsSpan();

            // 并行处理每一行
            Parallel.For(0, input.Height, y =>
            {
                for (int x = 0; x < input.Width; x++)
                {
                    for (int c = 0; c < input.Channels; c++)
                    {
                        float sum = 0;
                        
                        for (int k = 0; k < kernelSize; k++)
                        {
                            int px = x + k - offset;
                            
                            // 边界处理：镜像扩展
                            if (px < 0) px = -px;
                            if (px >= input.Width) px = 2 * input.Width - px - 2;
                            
                            int srcIndex = (y * input.Width + px) * input.Channels + c;
                            sum += srcSpan[srcIndex] * kernel[k];
                        }
                        
                        int dstIndex = (y * input.Width + x) * input.Channels + c;
                        dstSpan[dstIndex] = (byte)Math.Clamp(sum, 0, 255);
                    }
                }
            });

            return result;
        }

        /// <summary>
        /// 垂直方向高斯滤波
        /// </summary>
        private ImageData ApplyVerticalGaussian(ImageData input, float radius)
        {
            var kernel = GenerateGaussianKernel1D(radius);
            var result = input.Clone();
            int kernelSize = kernel.Length;
            int offset = kernelSize / 2;

            var srcSpan = input.PixelData.AsSpan();
            var dstSpan = result.PixelData.AsSpan();

            // 并行处理每一列
            Parallel.For(0, input.Width, x =>
            {
                for (int y = 0; y < input.Height; y++)
                {
                    for (int c = 0; c < input.Channels; c++)
                    {
                        float sum = 0;
                        
                        for (int k = 0; k < kernelSize; k++)
                        {
                            int py = y + k - offset;
                            
                            // 边界处理：镜像扩展
                            if (py < 0) py = -py;
                            if (py >= input.Height) py = 2 * input.Height - py - 2;
                            
                            int srcIndex = (py * input.Width + x) * input.Channels + c;
                            sum += srcSpan[srcIndex] * kernel[k];
                        }
                        
                        int dstIndex = (y * input.Width + x) * input.Channels + c;
                        dstSpan[dstIndex] = (byte)Math.Clamp(sum, 0, 255);
                    }
                }
            });

            return result;
        }

        /// <summary>
        /// 2D高斯滤波器实现
        /// </summary>
        private ImageData Apply2DGaussianBlur(ImageData input, float radius, int kernelSize = 0)
        {
            var kernel = GenerateGaussianKernel2D(radius, kernelSize);
            var result = input.Clone();
            int size = kernel.GetLength(0);
            int offset = size / 2;

            var srcSpan = input.PixelData.AsSpan();
            var dstSpan = result.PixelData.AsSpan();

            // 并行处理
            Parallel.For(offset, input.Height - offset, y =>
            {
                for (int x = offset; x < input.Width - offset; x++)
                {
                    for (int c = 0; c < input.Channels; c++)
                    {
                        float sum = 0;
                        
                        for (int ky = 0; ky < size; ky++)
                        {
                            for (int kx = 0; kx < size; kx++)
                            {
                                int px = x + kx - offset;
                                int py = y + ky - offset;
                                int srcIndex = (py * input.Width + px) * input.Channels + c;
                                sum += srcSpan[srcIndex] * kernel[ky, kx];
                            }
                        }
                        
                        int dstIndex = (y * input.Width + x) * input.Channels + c;
                        dstSpan[dstIndex] = (byte)Math.Clamp(sum, 0, 255);
                    }
                }
            });

            return result;
        }

        /// <summary>
        /// 生成1D高斯核
        /// </summary>
        private float[] GenerateGaussianKernel1D(float radius)
        {
            float sigma = radius / 3.0f; // 经验公式
            int size = (int)(6 * sigma) | 1; // 确保是奇数
            if (size < 3) size = 3;
            
            var kernel = new float[size];
            int center = size / 2;
            float sum = 0;

            for (int i = 0; i < size; i++)
            {
                int x = i - center;
                kernel[i] = (float)Math.Exp(-(x * x) / (2 * sigma * sigma));
                sum += kernel[i];
            }

            // 归一化
            for (int i = 0; i < size; i++)
            {
                kernel[i] /= sum;
            }

            return kernel;
        }

        /// <summary>
        /// 生成2D高斯核
        /// </summary>
        private float[,] GenerateGaussianKernel2D(float radius, int kernelSize = 0)
        {
            float sigma = radius / 3.0f;
            int size = kernelSize > 0 ? kernelSize : ((int)(6 * sigma) | 1);
            if (size < 3) size = 3;
            
            var kernel = new float[size, size];
            int center = size / 2;
            float sum = 0;

            for (int i = 0; i < size; i++)
            {
                for (int j = 0; j < size; j++)
                {
                    int x = i - center;
                    int y = j - center;
                    kernel[i, j] = (float)Math.Exp(-(x * x + y * y) / (2 * sigma * sigma));
                    sum += kernel[i, j];
                }
            }

            // 归一化
            for (int i = 0; i < size; i++)
            {
                for (int j = 0; j < size; j++)
                {
                    kernel[i, j] /= sum;
                }
            }

            return kernel;
        }
    }
}
```

### 3. 使用示例
```csharp
// 在UI中的使用
private async void ApplyGaussianBlur_Click(object sender, RoutedEventArgs e)
{
    if (_currentImage == null) return;

    try
    {
        var parameters = new GaussianBlurParameters
        {
            Radius = (float)RadiusSlider.Value,
            SeparableFilter = SeparableCheckBox.IsChecked ?? true
        };

        var filter = new GaussianBlurFilter();
        var result = await filter.ApplyAsync(_currentImage, parameters);
        
        _currentImage = result;
        ImageDisplay.Source = _currentImage.ToBitmapSource();
    }
    catch (Exception ex)
    {
        MessageBox.Show($"处理失败: {ex.Message}", "错误");
    }
}
```

## 性能对比

### D.cs原始实现
- **优点**: 使用native DLL，性能极高，支持SIMD优化
- **缺点**: 依赖外部DLL，不可移植，unsafe代码

### 重构后实现
- **优点**: 纯C#实现，安全代码，可移植，易维护
- **缺点**: 性能略低于native实现

### 性能优化建议
1. **使用Span<T>**: 减少数组边界检查
2. **并行处理**: Parallel.For提高多核利用率
3. **可分离滤波**: 将2D卷积分解为两个1D卷积
4. **内存池**: 复用临时缓冲区
5. **SIMD**: 使用System.Numerics.Vector进行向量化

## 总结

通过这个示例，我们展示了如何：
1. 分析D.cs中的算法调用模式
2. 理解算法的参数和功能
3. 重构为现代化的C#实现
4. 保持功能完整性的同时提高代码质量

这种方法可以应用于D.cs中的其他算法提取，为构建现代化的图像处理工具提供算法基础。
